/**
 * @file firmware.c
 * @author Purdue eCTF Team
 * @brief Firmware for the car
 * @date 2023
 *
 * This file contains the firmware for the car.
 *
 * @copyright Copyright (c) 2023 Purdue eCTF Team
 */

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "inc/hw_flash.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"

#include "driverlib/eeprom.h"
#include "driverlib/flash.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/timer.h"

#ifdef CDEBUG
#include "ustdlib.h"
#endif

#include "eeprom_wrapper.h"
#include "wrapper.h"

#include "board_link.h"
#include "feature_list.h"

/*** Macro Definitions ***/
#define UNLOCK_EEPROM_LOC 0x7C0
#define UNLOCK_EEPROM_SIZE 64

#define ENCRYPT_STRING_LEN 48
#define FEATURE_PSSWD_LEN 16
#define FOB_UNLOCK_RESP_LEN 16

/*** Struct and Enum Definitions ***/
/**
 * @struct FEATURE_DATA
 * @brief Structure for feature data
 *
 * @note enabled: each bit represents a feature, 1 if enabled, 0 if disabled
 *       feature_passwords: 16 byte passwords for each feature
 */
typedef struct {
  uint8_t enabled;
  uint8_t feature_passwords[NUM_FEATURES][FEATURE_PSSWD_LEN];
} __attribute__((packed)) FEATURE_DATA;

/**
 * @enum car_state_t
 * @brief States for the car
 */
typedef enum {
  STATE_IDLE, /**< Idle state */ 
  STATE_LOCKED, /**< Locked state */
  STATE_UNLOCKED, /**< Unlocked state */
  STATE_SEND_ENC, /**< Send encrypted challenge state */
  STATE_RECV_RESP, /**< Receive response state */
  STATE_DEFENSE, /**< Defense mode state */
  STATE_IN_PROGRESS /**< In progress state */
} car_state_t;

/**
 * @struct car_t
 * @brief Structure for the car
 *
 * @note current_state: the current state of the car
 *          car_random: the random number generated by the car
 */
typedef struct {
  car_state_t current_state; /**< Current state of the car */
  uint8_t car_random[CAR_KEY_LEN]; /**< Random number generated by the car */
} __attribute__((packed)) car_t;

/*** Function Definitions ***/

void unlockCar(void);
void startCar(void);
void wait_for_unlock(void);
void wait_for_response(void);
void send_encrpyted_challenge(void);
void defense_mode(void);
void sendAckSuccess(void);
void sendAckFailure(void);

/*** Global Variables ***/

car_t car; 
uint32_t feature_hashes[] = {FEATURE_KEY_1_HASH, FEATURE_KEY_2_HASH,
                             FEATURE_KEY_3_HASH};
uint32_t feature_hashes_len = FEATURE_KEY_1_HASH_LEN;

/**
 * @brief The main loop for the car
 */
int main(void) {
  // Protect Flash from being modified
  for (uint32_t block_start = 0x8000; block_start < 0x23800;
       block_start += FLASH_PROTECT_SIZE) {
    if (FlashProtectSet(block_start, FlashReadOnly)) {
      while (1)
        ;
    }
  }

  // Initialize the EEPROM
  SysCtlPeripheralEnable(SYSCTL_PERIPH_EEPROM0);
  EEPROMInit();

  // Initialize the UARTs
  setup_comms();

  // Car is green
  GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);          // r
  GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, 0);          // b
  GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, GPIO_PIN_3); // g

  // Initialize the random number generator
  srand();

#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR: Car main", 13);
#endif

  // Initialize the car state
  uint32_t defense = 0;
  read_eeprom(&defense, CAR_DEFENSE, CAR_DEFENSE_LEN);
  if (defense == 1)
    car.current_state = STATE_DEFENSE;
  else
    car.current_state = STATE_LOCKED;

  // Main loop
  while (true) {
    switch (car.current_state) {
    case STATE_LOCKED:
      wait_for_unlock();
      break;
    case STATE_SEND_ENC:
      send_encrpyted_challenge();
      break;
    case STATE_RECV_RESP:
      wait_for_response();
      break;
    case STATE_DEFENSE:
      defense_mode();
      car.current_state = STATE_LOCKED;
      break;
    case STATE_UNLOCKED:
      startCar();
      car.current_state = STATE_LOCKED;
      break;
    default:
      break;
    }
  }
}

/**
 * @brief The Idle state of the car, waits for a message from the fob
 *
 * @note This function sets the car state to STATE_SEND_ENC if a unlock message
 * is received
 */
void wait_for_unlock() {
  // retrieve the message
  MESSAGE_PACKET message;
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
  receive_message(BOARD_UART, &message);

  // check if the message is a unlock message
  if (message.header != UNLOCK_HDR || message.message_len != 0)
    return;

#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR: Received unlock message", 28);
#endif

  // update the car state
  rand(car.car_random);
  car.current_state = STATE_SEND_ENC;

  // clean up the message
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
}

/**
 * @brief Handles unlocking requests from the fob
 *
 * @note This function sends a challenge to the fob, then sets the car state to
 * STATE_RECV_RESP
 */
void send_encrpyted_challenge() {
  // Sanity check the state
  if (car.current_state != STATE_SEND_ENC)
    return;

  // create the challenge message
  MESSAGE_PACKET message;
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
  message.header = CHALLENGE_HDR;

  // encrypt the random number and send it to the fob
  uint8_t key[CAR_KEY_LEN];
  memset((void *)key, 0, CAR_KEY_LEN);
  read_eeprom(key, CAR_KEY, CAR_KEY_LEN);

  uint8_t challenge_buf[CAR_KEY_LEN] = {0};
  memcpy((void *)challenge_buf, (void *)car.car_random, CAR_KEY_LEN);
  uint8_t message_buf[ENCRYPT_STRING_LEN] = {0};

#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR SEC Key: ", 13);
  debug_send_array(HOST_UART, key, 16);
  debug_send_message(HOST_UART, "CAR SEC RAND: ", 13);
  debug_send_array(HOST_UART, challenge_buf, 16);
  debug_send_message(HOST_UART, "\n", 1);
#endif

  // The encrypt string returns the length of the encrypted string
  uint32_t len = encrypt_string(message_buf, challenge_buf, CAR_KEY_LEN, key);
  memset((void *)key, 0, CAR_KEY_LEN);
  memset((void *)challenge_buf, 0, CAR_KEY_LEN);
  if (len != ENCRYPT_STRING_LEN) {
#ifdef CDEBUG
    debug_send_message(
        HOST_UART, "Fatal Error: Encrypted string not equal to 48", 46);
#endif
    car.current_state = STATE_LOCKED;
    return;
  }
  message.message_len = (uint8_t)len;
  memcpy((void *)message.buffer, (void *)message_buf, message.message_len);
  memset((void *)message_buf, 0, ENCRYPT_STRING_LEN);

#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR SEC ENC:", 12);
  debug_send_array(HOST_UART, message.buffer, message.message_len);
#endif

  send_message(BOARD_UART, &message);

  // clean up the message and key, then update the state
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
  car.current_state = STATE_RECV_RESP;
}

/**
 * @brief Waits for the fob to respond to the challenge
 *
 * @note This function sets the car state to STATE_UNLOCKED if the fob responds
 * with the correct response, STATE_DEFENSE otherwise
 */
void wait_for_response() {

#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR: Waiting for response STATE_RECV_RESP ",
                     42);
#endif

  // Sanity check the state
  if (car.current_state != STATE_RECV_RESP)
    return;

  // Retrieve the message
  MESSAGE_PACKET message;
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
  receive_message(BOARD_UART, &message);
  if (message.header != UNLOCK_RES_HDR) {
    car.current_state = STATE_LOCKED;
    return;
  }

  if (message.message_len != FOB_UNLOCK_RESP_LEN) {
#ifdef CDEBUG
    debug_send_message(HOST_UART,
                       "CAR: Invalid response length kicking DEFENSE", 44);
#endif
    car.current_state = STATE_DEFENSE;
    uint32_t defense = 1;
    write_eeprom((uint8_t *)&defense, CAR_DEFENSE, CAR_DEFENSE_LEN);
    return;
  }

#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR RECVRESP: ", 14);
  debug_send_array(HOST_UART, message.buffer, 16);
#endif

  // Verify the response matches the random number
  if (memcmp(message.buffer, car.car_random, CAR_KEY_LEN) == 0) {
    car.current_state = STATE_UNLOCKED;
    sendAckSuccess();
  } else {
    car.current_state = STATE_DEFENSE;
    uint32_t defense = 1;
    write_eeprom((uint8_t *)&defense, CAR_DEFENSE, CAR_DEFENSE_LEN);
    sendAckFailure();
  }
}

/**
 * @brief Defense mode for the car
 *
 * @note Car will sleep for 4 seconds and then return to the locked state
 */
void defense_mode() {
#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR: Defense mode ", 18);
#endif
  if (car.current_state != STATE_DEFENSE)
    return;
  // sleep for 4 seconds
  ROM_SysCtlDelay(SysCtlClockGet() / 3 * 4);

  // reset the defense mode
  uint32_t defense = 0;
  write_eeprom((uint8_t *)&defense, CAR_DEFENSE, CAR_DEFENSE_LEN);

  // Set the car state to locked
  car.current_state = STATE_LOCKED;
}

/**
 * @brief Waits for the fob to send a start message
 *
 * @note This function handles the start message after the car has been
 * unlocked, verifies the feature list sent by the fob, then prints the unlock
 * message and feature list to the host. It then sets the car state to
 * STATE_LOCKED again.
 */
void startCar(void) {
#ifdef CDEBUG
  debug_send_message(HOST_UART, "CAR: Starting car ", 18);
#endif
  // Sanity check the state
  if (car.current_state != STATE_UNLOCKED)
    return;

  // Retrieve the message
  MESSAGE_PACKET message;
  receive_message(BOARD_UART, &message);
  if (message.header != START_HDR) {
    car.current_state = STATE_LOCKED;
    memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
    return;
  }

  // Send unlock message to host
  MESSAGE_PACKET host_message;
  memset((void *)&host_message, 0, sizeof(MESSAGE_PACKET));
  read_eeprom(host_message.buffer, UNLOCK_EEPROM_LOC, UNLOCK_EEPROM_SIZE);
  host_message.header = START_HDR;
  host_message.message_len = UNLOCK_EEPROM_SIZE;
  send_message(HOST_UART, &host_message);
  memset((void *)&host_message, 0, sizeof(MESSAGE_PACKET));

  // Extract features from message buffer
  if (message.message_len != sizeof(FEATURE_DATA)) {
    car.current_state = STATE_LOCKED;
    memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
    return;
  }
  FEATURE_DATA *feature_info = (FEATURE_DATA *)message.buffer;

  // Send feature list to host
  for (int i = 0; i < NUM_FEATURES; i++) {
    if (!(feature_info->enabled & (1 << i))) {
      continue;
    }

    uint8_t to_hash[UNLOCK_EEPROM_SIZE];
    read_eeprom(to_hash, CAR_SECRET_SALT, CAR_SECRET_SALT_LEN);
    memcpy(to_hash + CAR_SECRET_SALT_LEN, feature_info->feature_passwords[i],
           CAR_KEY_LEN);

#ifdef CDEBUG
    debug_send_message(HOST_UART, "HASHING: ", 9);
    debug_send_array(HOST_UART, to_hash, 64);
#endif

    uint8_t hash_from_fob[HASH_LEN];
    memset((void *)&hash_from_fob, 0, HASH_LEN);
    hash_string(hash_from_fob, to_hash, PLAINTEXT_LEN);

    uint8_t local_hash[HASH_LEN];
    memset((void *)local_hash, 0, HASH_LEN);
    read_eeprom(local_hash, feature_hashes[i], HASH_LEN);

#ifdef CDEBUG
    debug_send_message(HOST_UART, "HASH IN CAR: ", 13);
    debug_send_array(HOST_UART, local_hash, 32);
    debug_send_message(HOST_UART, "GENERATED: ", 11);
    debug_send_array(HOST_UART, hash_from_fob, 32);
#endif

    if (memcmp(hash_from_fob, local_hash, HASH_LEN) != 0) {
      car.current_state = STATE_LOCKED;
      return;
    }

    // clean up the hash buffers
    memset((void *)local_hash, 0, HASH_LEN);
    memset((void *)hash_from_fob, 0, HASH_LEN);

    // Send feature to host
    uint32_t offset = (i + 1) * FEATURE_SIZE;
    read_eeprom(host_message.buffer, FEATURE_END - offset, FEATURE_SIZE);
    host_message.header = HOST_FEATURE_HDR; 
    host_message.message_len = FEATURE_SIZE;
    send_message(HOST_UART, &host_message);
    memset((void *)&host_message, 0, sizeof(MESSAGE_PACKET));
  }

  // clean up the message buffer and return to locked state
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
  car.current_state = STATE_LOCKED;
}

/**
 * @brief Sends an ACK success message to the fob
 */
void sendAckSuccess(void) {
  MESSAGE_PACKET message;
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));

  message.header = ACK_HDR;
  message.buffer[0] = ACK_SUCCESS;
  message.message_len = 1;

  send_message(BOARD_UART, &message);
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
}

/**
 * @brief Sends an ACK failure message to the fob
 */
void sendAckFailure(void) {
  MESSAGE_PACKET message;
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));

  message.header = ACK_HDR;
  message.buffer[0] = ACK_FAIL;
  message.message_len = 1;

  send_message(BOARD_UART, &message);
  memset((void *)&message, 0, sizeof(MESSAGE_PACKET));
}
